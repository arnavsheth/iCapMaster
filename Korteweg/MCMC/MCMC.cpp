/*
=================================================================================
MCMC.cpp

Copyright (C) 2009 by Arthur Korteweg and Morten Sorensen
=================================================================================

This program implements the MCMC estimation of the dynamic selection model 
from the paper "Risk and Return Characteristics of Venture Capital 
Investments in Entrepreneurial Companies".

The algorithm estimates the model
	v_t = v_(t-1) + rf + delta + beta*rmrf + e_t			(valuation equation)
    W_t = Z_t * gamma_0 + (v_t - vF_t) * gamma_v + eta_t	(selection equation)

where e(t) ~ N(0, sigma^2) i.i.d.
	  eta(t) ~ N(0,1) i.i.d.
and e(t) and eta(t) are independent

vF_t is the log-valuation at the previous financing round.

Z_t = [1 tau tau^2] where tau is the number of periods since the previous 
observed valuation (i.e. financing round).

rf is assumed constant.

For details on the algorithm we refer to the above-mentioned paper.

Simulated data is loaded from 3 files that were generated by the 
Matlab program "Simdata.m":
	Simdata_info.dat		T (# periods), N (# firms), risk-free rate rf
	Simdata_logVobs.dat		log-valuations (TxN matrix), unobserved values are -999
	Simdata_rmrf.dat		rmrf (vector of length T-1)

Output is saved in 4 files:
	MCMCout_info.dat		G, the number of iterations of the Gibbs sampler
	MCMCout_b.dat			[delta, beta] draws (Gx2 matrix)
	MCMCout_gamma.dat		gamma draws (Gx4 matrix)
	MCMCout_sige2.dat		sigma^2 draws (Gx1 vector)

The Matlab program yyy.m loads and presents the output in a convenient way, 
and should be run after this program.

The program makes use of the free GSL numeric library for vector and matrix 
operations. More info and download at:
http://www.gnu.org/software/gsl/

Suggested compilation instructions for the g++ compiler:
g++ MCMC.cpp -o MCMC -lgsl -lm -lgslcblas -enable-auto-import
*/


#include <iostream>
#include <fstream>
#include <cmath>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_blas.h>
using namespace std;


double standardnormal_uppertrunc(const double u, gsl_rng * r) {
	// Returns a draws from an upper-truncated standard normal, truncated at "u" (i.e. no 
	// mass above u). 
	// Note: "r" is a pointer to the seed for the random number generator.
	double x;
	if (u > 0.0) {
		// if u > 0, draw x and reject until x <= u.
		do { x = gsl_ran_ugaussian_ratio_method(r); } while(x > u);		
		return x;
	}
	if (u > -0.6) {
		// if -0.6 < u =< 0, draw x until x <= u or x >= -u 
		// if x >= -u then invert the draw i.e. x = -x.
		do { x = gsl_ran_ugaussian_ratio_method(r); } while(x > u && x < -u) ;		
		if (x >= -u) { x = -x;}
		return x;
	} 
	// if u <= -0.6 then do accept-reject using exponential distribution as proposal (see e.g. Robert, 1995, p.122).
	do {x = log(gsl_rng_uniform(r)) / u; } while (gsl_rng_uniform(r) > exp(-x*x/2.0)); 
	return u - x;
}

double randn_uppertrunc(const double bound, const double mu, const double sigma, gsl_rng * r) {
	// Returns a draw from an upper-truncated normal with mean "mu" and standard 
	// deviation "sigma", truncated from above at "bound".
	// Note: "r" is a pointer to the seed for the random number generator.
	double zbound = (bound - mu) / sigma;				// translate bound to a standard normal
	double z = standardnormal_uppertrunc(zbound , r);	// draw z from upper-truncated standard normal
	return mu + z * sigma;								// scale z back to Normal(mu, sigma)
}

double randn_lowertrunc(const double bound, const double mu, const double sigma, gsl_rng * r) {
	// Returns a draw from a lower-truncated normal with mean "mu" and standard 
	// deviation "sigma", truncated from below at "bound".
	// Note: "r" is a pointer to the seed for the random number generator.
	return -randn_uppertrunc(-bound, -mu, sigma, r);	// flip distribution around vertical axis and use the upper-truncated function
}

void Bayesregr_sigknown(const gsl_matrix* X, const gsl_vector* y, gsl_vector* beta, const gsl_vector* beta0, const gsl_matrix* A, const double sigma2, gsl_rng * r) {
	// Draws from the posterior distribution of an OLS regressions where sigma^2 is known.
	// Prior:
	//			beta ~ N(beta0 , sigma2 * inv(A) )
	// X is the matrix of regressors (including a constant, if any).
	// y is the vector of independent variables.
	// Returns the draw for beta in the vector "beta".
	// Note: "r" is a pointer to the seed for the random number generator.

	int K = X->size2;	// number of regressors

	gsl_matrix * XX		= gsl_matrix_alloc (K, K);	// auxiliary matrix
	gsl_vector * XY		= gsl_vector_alloc (K);		// auxiliary
	gsl_vector * z		= gsl_vector_alloc (K);		// contains i.i.d. Normal draws
	
	// initialize XX = A and XY = A*B0
	gsl_matrix_memcpy (XX, A);	
	gsl_blas_dgemv (CblasNoTrans, 1.0, A, beta0, 0.0, XY);

	// calculate XX = (X'X + A)/sigma2 and XY = (X'y + A*B0)/sigma2
	gsl_blas_dgemm (CblasTrans, CblasNoTrans, 1.0/sigma2, X, X, 1.0/sigma2, XX);
	gsl_blas_dgemv (CblasTrans, 1.0/sigma2, X, y, 1.0/sigma2, XY);

	// draw from independent Normals: z ~ N(0, I)
	for (int i = 0; i < K; i++) {
		gsl_vector_set (z, i, gsl_ran_ugaussian_ratio_method(r));
	}
	
	// take cholesky factor of XX (saved in XX)
	gsl_linalg_cholesky_decomp (XX);
	
	// calculate correlated Normal draws: z = inv(XX) * z 
	gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, XX, z);

	// solve for posterior mean beta using cholesky decomposition (output in "beta"): 
	//		(X'X+A)/sigma2 * beta = (X'y+A*B0)/sigma2
	gsl_linalg_cholesky_solve (XX, XY, beta);

	// add the random component: beta = beta + z
	gsl_vector_add (beta, z);

	gsl_matrix_free (XX);	// release memory
	gsl_vector_free (XY);
	gsl_vector_free (z);
	
	return;
}

void Bayesregr(const gsl_matrix* X, const gsl_vector* y, gsl_vector* beta, const gsl_vector* beta0, const gsl_matrix* A, double& sigma2, const double a0, const double b0, gsl_rng * r) {
	// Draws from the posterior distribution of a Normal-IG prior OLS regressions
	// Priors:
	//			sigma2 ~ IG(a0, b0)
	//			beta|sigma2 ~ N(beta0 , sigma2 * inv(A) )
	// X is the matrix of regressors (including a constant, if any).
	// y is the vector of independent variables.
	// Returns the draw for beta in the vector "beta" and the draw for sigma^2 in "sigma2"
	// Note: "r" is a pointer to the seed for the random number generator.
	
	double a;		// posterior sigma2 ~ IG(a, b)
	double b;
	double bb;		// used for calculating b
	double ee;		// idem

	int N = X->size1;	// number of observations
	int K = X->size2;	// number of regressors

	gsl_matrix * XX		= gsl_matrix_alloc (K, K);	// auxiliary matrix
	gsl_vector * XY		= gsl_vector_alloc (K);		// auxiliary
	gsl_vector * z		= gsl_vector_alloc (K);		// contains i.i.d. Normal draws
	gsl_vector * e		= gsl_vector_alloc (N);		// contains residuals: y - X * mean beta
	gsl_vector * bminb0	= gsl_vector_alloc (K);		// posterior mean beta - beta0
	gsl_vector * temp	= gsl_vector_alloc (K);		// auxiliary

	// initialize XX = A and XY = A*B0
	gsl_matrix_memcpy (XX, A);	
	gsl_blas_dgemv (CblasNoTrans, 1.0, A, beta0, 0.0, XY);

	// calculate XX = (X'X + A) and XY = (X'y + A*B0)
	gsl_blas_dgemm (CblasTrans, CblasNoTrans, 1.0, X, X, 1.0, XX);
	gsl_blas_dgemv (CblasTrans, 1.0, X, y, 1.0, XY);

	// take cholesky factor of XX (saved in XX)
	gsl_linalg_cholesky_decomp (XX);

	// solve for posterior mean beta using cholesky decomposition (output in "beta"): 
	//		(X'X+A) * beta = (X'y+A*B0)
	gsl_linalg_cholesky_solve (XX, XY, beta);

	// compute e = Y - X*beta (NB: uses posterior mean beta!)
	gsl_vector_memcpy (e, y);
	gsl_blas_dgemv (CblasNoTrans, -1.0, X, beta, 1.0, e);

	// compute ee = e'e
	gsl_blas_ddot (e, e, &ee);

	// compute bb = (beta-beta0)'*A*(beta-beta0) where beta is posterior mean
	gsl_vector_memcpy (bminb0, beta);
	gsl_vector_sub (bminb0, beta0);							// bminb0 = beta - beta0
	gsl_blas_dsymv (CblasUpper, 1.0, A, bminb0, 0.0, temp);	// temp = A*(beta-beta0) noting that A is symmetric
	gsl_blas_ddot (temp, bminb0, &bb);						// bb = temp'*(beta-beta0)

	// compute posterior a and b
	a = a0 + N;		
	b = 1.0 / ((1.0 / b0) + ee + bb);				// b^(-1) = b0^(-1) + e'e + (beta-beta0)'*A*(beta-beta0)

	// draw sigma2 from posterior IG (a,b)
	sigma2 = 1.0 / gsl_ran_gamma_knuth (r, a, b);
	
	// calculate XX = cholesky factor of (X'X + A)/sigma2 = chol(X'X + A)/sqrt(sigma2) 
	gsl_matrix_scale (XX, 1.0 / sqrt(sigma2) );		// XX already contains chol(X'X + A), so just scale by 1/sqrt(sigma2)

	// draw from independent Normals: z ~ N(0, I)
	for (int i = 0; i < K; i++) {
		gsl_vector_set (z, i, gsl_ran_ugaussian_ratio_method(r));
	}

	// calculate correlated Normal draws: z = inv(XX) * z 
	gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, XX, z);
	
	// add the random component to the mean to get a draw of beta: beta = beta + z
	gsl_vector_add (beta, z);

	gsl_matrix_free (XX);		// release memory
	gsl_vector_free (XY);
	gsl_vector_free (z);
	gsl_vector_free (e);
	gsl_vector_free (bminb0);
	gsl_vector_free (temp);

	return;
}


int main(void) 
{
const char* infoname = "Simdata_info.dat";		// this file contains T and N (# periods and firms), and the risk-free rate
const char* Vobsname = "Simdata_logVobs.dat";	// contains simulated log-valuations (-999 for missing valuations)
const char* rmrfname = "Simdata_rmrf.dat";		// simulated rm-rf

int	T;			// number of time periods
int	N;			// number of firms
double rf;		// risk-free rate

// Load T, N, and the risk-free rate rf
double TT;
double NN;
ifstream info (infoname);
info >> TT >> NN >> rf;		// Matlab saves numbers as doubles: convert TT and NN to int below
info.close ();
T = (int)TT;
N = (int)NN;

// Load log-valuation data for each "firm"
gsl_matrix * logVobs = gsl_matrix_alloc (T, N);
FILE * f_V = fopen(Vobsname, "r");			// Note, file is in row order (counter intuitive)
gsl_matrix_fscanf(f_V, logVobs);
fclose(f_V);

// Load market factor, rm-rf
gsl_vector * rmrf = gsl_vector_alloc (T-1); // there are only T-1 returns based on a total of T time periods 
FILE * f_rmrf = fopen(rmrfname, "r");		// Note, file is in row order (counter intuitive)
gsl_vector_fscanf(f_rmrf, rmrf);			
fclose(f_rmrf);


// Define constants
const int KF = 1;		// number of factors (i.e. 1 for market model, 3 for FF)
const int KS = 3;		// number of variables in selection equation (excluding constant)
const int G = 6000; 	// number of cycles of MCMC sampler


// Initialize vectors and matrices that will hold the parameter draws
gsl_vector * b			= gsl_vector_alloc (KF+1);		// b = [delta, beta]
gsl_vector * gamma		= gsl_vector_alloc (KS+1);		// g = gammas
gsl_matrix * bsave		= gsl_matrix_alloc (G, KF+1);	// saves the draws for b across cycles
gsl_matrix * gamsave	= gsl_matrix_alloc (G, KS+1);	// saves the draws for gamma across cycles
gsl_vector * sige2save	= gsl_vector_alloc (G);			// saves the draws for sige2 across cycles
gsl_matrix * eta		= gsl_matrix_alloc (T, N);		// error term of selection equation (not saved across samples)
gsl_matrix * logV		= gsl_matrix_alloc (T, N);		// latent log-valuations, v (not saved across samples)


// Initialize priors
const double pr_s2a		= 2.1;						// prior sige2 ~ IG (pr_s2a, pr_s2b)
const double pr_s2b		= 600.0;
gsl_vector * b0		= gsl_vector_alloc (KF+1);		// prior b ~ N(b0, inv(A)*sige2)
gsl_matrix * A		= gsl_matrix_alloc (KF+1, KF+1); 
gsl_vector * g0		= gsl_vector_alloc (KS+1);		// prior gamma ~ N(g0, inv(C))
gsl_matrix * C		= gsl_matrix_alloc (KS+1, KS+1);
gsl_vector_set_all (b0, 0.0);						// set b0 = all zeros
gsl_vector_set_all (g0, 0.0);						// set g0 = all zeros
// A = 1/10000 * Identity matrix
gsl_matrix_set_all (A, 0.0); for (int i = 0; i < KF+1; i++) {gsl_matrix_set(A, i, i, 1/10000.0);}	
// C = 1/100 * Identity matrix
gsl_matrix_set_all (C, 0.0); for (int i = 0; i < KS+1; i++) {gsl_matrix_set(C, i, i, 1/100.0);}		


// Set starting values for b, gamma and sigma^2
gsl_vector_memcpy (b, b0);		// start betas at beta0 (prior mean)
gsl_vector_memcpy (gamma, g0);	// start gammas at gamma0 (prior mean)
double sige2 = 0.1*0.1;			// starting value of sige2
gsl_matrix_set_all(eta, 0.0);	


// Calculate start and end times for each firm
int Tstrt[N];			// array that holds the start times for each firm (first observed period)
int Tend[N];			// array that holds the end times for each firm (end of dataset)
int numrets = 0;		// count the total number of returns across all firms (used below)
for (int i = 0; i < N; i++) {
	Tstrt[i] = 0;
	Tend[i] = T - 1;									// adjust for first index = 0
	while (gsl_matrix_get(logVobs,Tstrt[i],i) == -999) {Tstrt[i]++;}	// find first observed valuation (-999 are missing valuations)
	numrets += Tend[i] - Tstrt[i];						// add number of observed returns for firm i
}

gsl_vector * rV = gsl_vector_alloc (numrets);			// used in Gibbs sampler to draw b
gsl_matrix * XV = gsl_matrix_alloc (numrets, KF+1);		// idem
gsl_vector * yg = gsl_vector_alloc (numrets);			// used in Gibbs sampler to draw gamma
gsl_matrix * Xg = gsl_matrix_alloc (numrets, KS+1);		// idem


// Set up X_select = [constant log(V_t)-log(VF) tau tau^2] for selection equation (stacking firms vertically)
// NB: The selection equation is W = X_select * gamma + eta
// Also initialize logVF to contain the log-valuation at previous financing event
gsl_matrix * X_select = gsl_matrix_alloc(T * N, KS+1);
gsl_matrix_set_all(X_select, 0.0);				// initialize X_select to all zeros

gsl_matrix * logVF = gsl_matrix_alloc(T,N);		// log-valuation at previous financing event
gsl_matrix_set_all(logVF, 0.0);					// initialize logVF at all zeros

for (int i = 0; i < N; i++) {
	double tau;											// counts the time since the previous financing round
	for (int t = Tstrt[i]; t <= Tend[i]; t++) {			// loop through dates, starting at first observed round
		gsl_matrix_set(X_select, i * T + t, 0, 1.0);	// fill in X_select = [1 logV-logVF tau tau^2]
		gsl_matrix_set(X_select, i * T + t, 1, gsl_matrix_get(logV, t, i)-gsl_matrix_get(logVF, t, i) );	
		gsl_matrix_set(X_select, i * T + t, 2, tau);	// set time since last financing round and 
		gsl_matrix_set(X_select, i * T + t, 3, tau*tau);//		its squared value
		if (t < T-1) {									// now fill in next period's logVF
			if ( gsl_matrix_get(logVobs, t,i) == -999.0 ) { // if valuation unobserved: logVF remains unchanged
				gsl_matrix_set(logVF, t+1, i, gsl_matrix_get(logVF, t, i));
				tau++;										// increase time since previous financing round
			} else {										// if valuation observed
				gsl_matrix_set(logVF, t+1, i, gsl_matrix_get(logVobs, t, i));	// logVF for next period contains the newly observed valuation  
				tau = 1.0;									// reset time since previous financing round
			}
		}
	}	
}	


// Init GSL random number generator
gsl_rng_env_setup();
const gsl_rng_type * gsl_T = gsl_rng_ranlxd2;
gsl_rng * gsl_r = gsl_rng_alloc(gsl_T);



/*********************************
 Start Gibbs Sampler
*********************************/

for (int g = 0; g < G; g++) {

	// output g every 100 cycles to show progress
	if (g % 100 == 0) {
		cout << g << endl;
	}


	// Draw v: use FFBS to draw the missing valuations conditional on draws of beta, gamma, 
    //         sigma^2, the selection variable W, and observed valuations.
    //         Use Kalman Filter and FFBS. The state-space is (for a given firm):
    //            State Diffusion:			X_t = X_(t-1) + rf + delta + beta*rmrf + e_t
    //            Observation equations:	X*_t = X_t * D_t
    //										W_t  = Z_t * gamma_0 + X_t * gamma_v + eta_t
    //         where X_t = v_t and D_t is a (known) vector of 1's one 0's, depending on
    //         whether v_t is observed in a particular month.
	double EXtt[T];					// E(v_t | t)
	double EXfwtt[T];				// E(v_(t+1) | t)
	double VXtt[T];					// Var(v_t | t)
	for (int i = 0; i < N; i++) {	// loop through all N firms separately
		double EX;					// define auxiliary variables
		double VX; 
		double EXfw;
		double VXfw;
		double dt;
		double e;
		double K;
		double r;
		double q;
		double gammav = gsl_vector_get (gamma, 1);	// gammav = loading on log(V)-log(VF) in selection equation
		double Xdraw;

		// Step A) Filter Forward to get the mean and variance of v(t|t), stored
		//		   in EXtt and VXtt
		for (int t = Tstrt[i]; t <= Tend[i]; t++) {
			// A1) The updating step		
			if (gsl_matrix_get (logVobs, t, i) != -999.0) {			// if V_t observed
				EX		= gsl_matrix_get (logVobs, t, i);			// observations are without error
				VX		= 0.0;									
			} else {												// V_t unobserved: apply filter using W_t as an "observation" of v_t
				e		= gammav * (gsl_matrix_get(logV, t, i) - EXfw) + gsl_matrix_get (eta, t, i);	// note that this conditional on W (which includes the prior draw for v)
				K		= gammav * VXfw / (1 + gammav*gammav*VXfw);	// compute Kalman gain K
				EX		= EXfw + K*e;								// E(v_t | t)   = E(v_t | t-1) + K * e
				VX		= VXfw - K*gammav*VXfw;						// Var(v_t | t) = Var(v_t | t-1) * (1 - K*gammav)
			}
			// A2) The forecasting step
			if (t < Tend[i]) {		// don't need the last dt because we don't need E(v_(T+1) | T)
				dt = rf + gsl_vector_get(b, 0) + gsl_vector_get(b, 1) * gsl_vector_get(rmrf, t);	// dt = rf + delta + beta*rmrf
			}
			EXfw		= EX + dt;		// E(v_(t+1) | t) = E(v_t | t) + rf + delta + beta*rmrf
			VXfw		= VX + sige2;	// Var(v_(t+1) | t) = Var(v_t | t) + sigma^2
			EXtt[t]		= EX;			// Keep E(v_t | t) for use in backward sampling step
			EXfwtt[t]	= EXfw;			// Keep E(v_(t+1) | t)
			VXtt[t]		= VX;			// Keep Var(v_t | t)
		}  // for t


		// Step B) Sample Backward: to get a draw from the conditional 
		//         distribution of X
		// First draw the last element of X from its conditional normal:
		Xdraw = EXtt[Tend[i]] + sqrt(VXtt[Tend[i]]) * gsl_ran_ugaussian_ratio_method (gsl_r);	// draw v_T|T
		gsl_matrix_set (logV, Tend[i], i, Xdraw);			
		// Now draw the rest of the state vector (see Carter & Kohn (1994), p.552), working backwards:
		for (int t = Tend[i]-1; t >= Tstrt[i]; t--) {
			if (VXtt[t] == 0) {
				Xdraw = EXtt[t];					// quicker than the filtering step below, if there is zero variance
			} else {
				e = Xdraw - EXfwtt[t];				// difference between draw of v_(t+1)|T and E(v_(t+1)|t)
				K = VXtt[t] / (VXtt[t] + sige2);	// compute Kalman gain
				r = EXtt[t] + K * e;				// E(v_t|T) = E(v_t|t) + K * e
				q = VXtt[t] * (1 - K);				// Var(v_t|T) = Var(v_t|t) * (1 - K)
				Xdraw = r + sqrt(q) * gsl_ran_ugaussian_ratio_method (gsl_r);	// draw v_t|T
			}
			gsl_matrix_set (logV, t, i, Xdraw);		// fill in logV with the draw of v_t|T
		}  // for t		
	}  // for i


	// Draw eta, the error term of the selection equation
	double bound;
	for (int i = 0; i < N; i++) {
		for (int t = Tstrt[i]; t <= Tend[i]; t++) {
			// update the variables in the selection equation with the new draws of log(V)
			gsl_matrix_set(X_select, i * T + t, 1, gsl_matrix_get(logV, t, i)-gsl_matrix_get(logVF, t, i) );	
			// calculate the truncation bound for drawing the eta's
			gsl_vector_view X_select_ti = gsl_matrix_row (X_select, i*T+t);
			gsl_blas_ddot (&X_select_ti.vector, gamma, &bound);		// truncation bound = -Xselect(t,:,i)'*gamma;
			bound = -bound;
			if (gsl_matrix_get(logVobs, t, i) != -999) {							// if V_t observed
				gsl_matrix_set(eta, t, i, randn_lowertrunc(bound, 0, 1, gsl_r));	// truncate eta from below
			} else {																// if V_t not observed
				gsl_matrix_set(eta, t, i, randn_uppertrunc(bound, 0, 1, gsl_r));	// truncate eta from above
			}
		}	// for t
	}	// for i
	

	// Draw delta, beta and sigma^2 from the posterior distribution of a Bayesian regression, using Normal-IG priors 
	int count = 0;		
	for (int i = 0; i < N; i++) {		// loop to fill in rV and XV for the Bayesian regression rV = XV*b + epsilon
		for (int t = Tstrt[i]; t < Tend[i]; t++) {
			gsl_vector_set (rV, count, gsl_matrix_get(logV, t+1, i) - gsl_matrix_get(logV, t, i) - rf);	// excess return
			gsl_matrix_set (XV, count, 0, 1.0);								// fill in XV = [1 rmrf]
			gsl_matrix_set (XV, count, 1, gsl_vector_get(rmrf, t) );		// rmrf from t to t+1 
			count++;
		} // for t
	} // for i
	Bayesregr (XV, rV, b, b0, A, sige2, pr_s2a, pr_s2b, gsl_r);		// Draw new b = [delta, beta] and sige2 = sigma^2


	// Draw gamma from the posterior distribution of a Bayesian regression, using a Normal prior (and known variance)
	double temp;
	count = 0;		
	for (int i = 0; i < N; i++) {		// loop to fill in Xg and yg for the Bayesian regression yg = Xg*gamma + eta
		for (int t = Tstrt[i]+1; t <= Tend[i]; t++) {				// exclude Tstrt since tau unknown
			// fill in Xg
			gsl_vector_view X_select_ti = gsl_matrix_row (X_select, i*T+t);	 
			gsl_vector_view Xg_count	= gsl_matrix_row (Xg, count);
			gsl_vector_memcpy (&Xg_count.vector, &X_select_ti.vector);		// Xg(count,:) = X_select_ti
			// fill in yg
			gsl_blas_ddot (&X_select_ti.vector, gamma, &temp);		// temp = X_select_ti'*gamma
			temp += gsl_matrix_get(eta, t, i);						// temp = X_select_ti'*gamma + eta_ti, which is W_ti 
			gsl_vector_set (yg, count, temp);						// yg(count) = temp
			count++;
		} // for t
	} // for i
	Bayesregr_sigknown (Xg, yg, gamma, g0, C, 1.0, gsl_r);			// Draw new gamma, imposing sigma_eta = 1


	// Store the current draws of beta, gamma, and sige2
	gsl_vector_view bsave_g   = gsl_matrix_row (bsave, g);
	gsl_vector_view gamsave_g = gsl_matrix_row (gamsave, g);
	gsl_vector_memcpy (&bsave_g.vector, b);
	gsl_vector_memcpy (&gamsave_g.vector, gamma);
	gsl_vector_set (sige2save, g, sige2);

}	// end of Gibbs loop "for g"


// Save the draws of b, gamma, sige2 to three separate files, and 
// save G in a separate file.
FILE * f_b = fopen ("MCMCout_b.dat", "w");			// Note, file is in row order (counter intuitive)
gsl_matrix_fprintf (f_b, bsave, "%4.10f");
fclose (f_b);
FILE * f_g = fopen ("MCMCout_gamma.dat", "w");		// Note, file is in row order (counter intuitive)
gsl_matrix_fprintf (f_g, gamsave, "%4.10f");
fclose (f_g);
FILE * f_s = fopen ("MCMCout_sige2.dat", "w");		// Note, file is in row order (counter intuitive)
gsl_vector_fprintf (f_s, sige2save, "%4.10f");
fclose (f_s);
ofstream infoout ("MCMCout_info.dat");
infoout << G;		
infoout.close ();

// Clean up
gsl_matrix_free (logVobs);
gsl_vector_free (rmrf);
gsl_matrix_free (X_select);
gsl_matrix_free (logVF);

gsl_vector_free (rV);
gsl_matrix_free (XV);
gsl_vector_free (yg);
gsl_matrix_free (Xg);

gsl_vector_free (b0);
gsl_matrix_free (A);
gsl_vector_free (g0);
gsl_matrix_free (C);

gsl_vector_free (b);
gsl_vector_free (gamma);
gsl_matrix_free (bsave);
gsl_matrix_free (gamsave);
gsl_vector_free (sige2save);
gsl_matrix_free (eta);
gsl_matrix_free (logV);

gsl_rng_free (gsl_r);

return 0;
}
